+++
date = '2025-10-14T18:40:10+01:00'
draft = false
title = '3ª Sessão - 10/10/2025'
+++

# 3ª Sessão - 10/10/2025

## Mais sobre condicionais

Mais detalhes sobre o uso de `if` statements que ficaram por ver da sessão anterior.

{{% hint info %}}
Nos exemplos de código a seguir, comentários do tipo `// => ...` indicam o que o bloco de código que está antes imprime!
{{% /hint %}}

### Desigualdade `!=` e `!==`

Na sessão anterior vimos os operadores de igualdade `==` e `===`.
Existem também os operadores de desigualdade `!=` e `!==`.

- `!=` verifica se dois valores são diferentes, fazendo conversão de tipos se necessário.
- `!==` verifica se dois valores são diferentes, sem fazer conversão de tipos.

Exemplos:

```javascript
5 != '5'          // false, porque '5' é convertido para 5
5 !== '5'         // true, porque os tipos são diferentes (number vs string)
5 != 6            // true, porque 5 é diferente de 6
5 !== 6           // true, porque 5 é diferente de 6
null != undefined // false, porque null e undefined são considerados iguais com conversão
```

Os operadores `!=` e `!==` são muito usados em `if` statements, por criarem expressões booleanas:

```javascript
let username = 'user123';
if (username !== 'admin') {
    console.log('O utilizador não é admin');
}
// => O utilizador não é admin
```

{{% hint caution %}}
**Nota:** Tal como com `==` e `===`, é geralmente recomendado usar `!==` em vez de `!=` para evitar surpresas com conversão de tipos.
{{% /hint %}}

### Not (`!`)

O operador `!` é o operador lógico de negação (NOT).
Ele inverte o valor booleano de uma expressão.

Exemplos:

```javascript
!true          // false
!false         // true
!(5 == '5')    // false, porque 5 == '5' é true
!(5 === '5')   // true, porque 5 === '5' é false
```

O operador `!` é muito usado em `if` statements para inverter o resultado de uma expressão:

```javascript
let loggedIn = false;
if (!isLoggedIn) {
    console.log('O utilizador não está logado');
}
// => O utilizador não está logado
```

Se tivermos uma variável booleana, este operador pode ser usado para se quisermos trocar o valor dessa variável.
Por exemplo se tivermos uma variável `isOpen` e quisermos trocar o valor dela de `true` para `false` ou de `false` para `true`, podemos fazer:

```javascript
isOpen = !isOpen;
```

Também poderíamos fazer:

```javascript
if (isOpen) {
    // Bloco then - aqui isOpen é true, passamos para false
    isOpen = false;
} else {
    // Bloco else - aqui isOpen é false, passamos para true
    isOpen = true;
}
```

No entanto escrever apenas `isOpen = !isOpen;` é mais conciso e direto, obtendo-se o mesmo resultado.

### `else if`

Até agora vimos `if` statements com apenas um bloco `then` e no máximo um bloco `else`.
No entanto, por vezes queremos verificar múltiplas condições diferentes

Por exemplo, podemos querer verificar se um número é positivo, negativo ou zero.
Com base no que sabemos até ao momento, poderiamos escrever:

```javascript
let numero = 0;
if (numero > 0) {
    console.log('O número é positivo');
} else {
    // Aqui sabemos que numero não é > 0 porque estamos no bloco else
    // Significa que pode ser < 0 ou == 0
    // Fazemos um novo if para distinguir os dois casos
    if (numero < 0) {
        console.log('O número é negativo');
    } else {
        console.log('O número é zero');
    }
}
// => O número é zero
```

No entanto, aninhar `if` statements dentro de blocos `else` pode tornar o código difícil de ler.
Para evitar isso, podemos usar `else if` para verificar múltiplas condições sequencialmente, se as condições anteriores forem falsas.

O exemplo acima pode ser reescrito para:

```javascript
let numero = 0;
if (numero > 0) {
    console.log('O número é positivo');
} else if (numero < 0) {
    console.log('O número é negativo');
} else {
    console.log('O número é zero');
}
// => O número é zero
```

### Ordenação de strings

Strings também podem ser comparadas com os operadores `<`, `>`, `<=` e `>=`.
A ordenação é feita com base na ordem lexicográfica (ordem alfabética) das letras da string.
De forma simples, podemos pensar que uma string é "maior" que outra se vier depois no dicionário.

Exemplos:

```javascript
'apple' < 'banana'   // true, porque 'apple' vem antes de 'banana' alfabeticamente
'grape' > 'apple'    // true, porque 'grape' vem depois de 'apple'
'cat' <= 'cat'       // true, porque são iguais
'cat' >= 'bat'       // true, porque 'cat' vem depois de 'bat'
```

As strings podem ter diferentes comprimentos.
Quando comparamos strings de diferentes comprimentos, a comparação é feita letra a letra até que uma diferença seja encontrada.
Quando uma diferença é encontrada, a comparação é determinada pela ordem das letras diferentes.
Se a letra na posição onde as strings diferem for maior na primeira string, então a primeira string é considerada "maior".
Se uma string for um prefixo da outra (começar pelo mesmo conjunto de letras), a string mais curta é considerada "menor".

Exemplos:

```javascript
'cat' < 'catalog'  // true, porque 'cat' é prefixo de 'catalog'
'bat' > 'batman'   // false, porque 'bat' é prefixo de 'batman'
```

As strings podem ter outros caracteres além de letras, como números, espaços e símbolos.
A ordenação desses caracteres segue a [tabela ASCII](https://pt.wikipedia.org/wiki/ASCII#Sinais_gr%C3%A1ficos_(imprim%C3%ADveis)).
A tabela ASCII define um número para cada caracter, e a ordenação de strings é feita caracter a caracter com base nesses números.

Exemplos:

```javascript
'123' < 'abc' // true, porque '1' (número ascii 49) vem antes de 'a' (número ascii 97)
' ' < 'A'     // true, porque espaço (número ascii 32) vem antes de 'A' (número ascii 65)
'!' < 'A'     // true, porque '!' (número ascii 33) vem antes de 'A' (número ascii 65)
```